From ba6e5ca67160f3847b0e68a0f7bc16d12989f2b4 Mon Sep 17 00:00:00 2001
From: Jeenu Viswambharan <jeenu.viswambharan@arm.com>
Date: Thu, 2 Aug 2018 10:14:12 +0100
Subject: [PATCH] SDEI: MISRA fixes

These changes address most of the required MISRA rules. In the process,
some from generic code is also fixed.

No functional changes.

Change-Id: I6235a355e006f0b1c7c1c4d811b3964a64d0434f
Signed-off-by: Jeenu Viswambharan <jeenu.viswambharan@arm.com>
---
 include/bl31/interrupt_mgmt.h             |   6 +-
 include/lib/el3_runtime/aarch64/context.h |   6 +-
 include/services/sdei.h                   | 113 +++++------
 services/std_svc/sdei/sdei_event.c        |   9 +-
 services/std_svc/sdei/sdei_intr_mgmt.c    | 118 ++++++-----
 services/std_svc/sdei/sdei_main.c         | 232 +++++++++++-----------
 services/std_svc/sdei/sdei_private.h      | 102 +++++-----
 services/std_svc/sdei/sdei_state.c        |   8 +-
 8 files changed, 298 insertions(+), 296 deletions(-)

diff --git a/include/bl31/interrupt_mgmt.h b/include/bl31/interrupt_mgmt.h
index 905dcd669..13c46e346 100644
--- a/include/bl31/interrupt_mgmt.h
+++ b/include/bl31/interrupt_mgmt.h
@@ -101,9 +101,9 @@
  ******************************************************************************/
 #define INTR_SRC_SS_FLAG_SHIFT		U(0)		/* BIT[0] */
 #define INTR_SRC_SS_FLAG_MASK		U(1)
-#define set_interrupt_src_ss(flag, val)	(flag |= val << INTR_SRC_SS_FLAG_SHIFT)
-#define clr_interrupt_src_ss(flag)	(flag &= ~(U(1) << INTR_SRC_SS_FLAG_SHIFT))
-#define get_interrupt_src_ss(flag)	((flag >> INTR_SRC_SS_FLAG_SHIFT) & \
+#define set_interrupt_src_ss(flag, val)	((flag) |= (val) << INTR_SRC_SS_FLAG_SHIFT)
+#define clr_interrupt_src_ss(flag)	((flag) &= ~(U(1) << INTR_SRC_SS_FLAG_SHIFT))
+#define get_interrupt_src_ss(flag)	(((flag) >> INTR_SRC_SS_FLAG_SHIFT) & \
 					 INTR_SRC_SS_FLAG_MASK)
 
 #ifndef __ASSEMBLY__
diff --git a/include/lib/el3_runtime/aarch64/context.h b/include/lib/el3_runtime/aarch64/context.h
index a2ce9f828..b990674c7 100644
--- a/include/lib/el3_runtime/aarch64/context.h
+++ b/include/lib/el3_runtime/aarch64/context.h
@@ -241,9 +241,9 @@ DEFINE_REG_STRUCT(cve_2018_3639, CTX_CVE_2018_3639_ALL);
  * Macros to access members of any of the above structures using their
  * offsets
  */
-#define read_ctx_reg(ctx, offset)	((ctx)->_regs[offset >> DWORD_SHIFT])
-#define write_ctx_reg(ctx, offset, val)	(((ctx)->_regs[offset >> DWORD_SHIFT]) \
-					 = val)
+#define read_ctx_reg(ctx, offset)	((ctx)->_regs[(offset) >> DWORD_SHIFT])
+#define write_ctx_reg(ctx, offset, val)	(((ctx)->_regs[(offset) >> DWORD_SHIFT]) \
+					 = (uint64_t) (val))
 
 /*
  * Top-level context structure which is used by EL3 firmware to
diff --git a/include/services/sdei.h b/include/services/sdei.h
index 79d1d065d..4d0fd3fd3 100644
--- a/include/services/sdei.h
+++ b/include/services/sdei.h
@@ -4,61 +4,56 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
-#ifndef __SDEI_H__
-#define __SDEI_H__
+#ifndef SDEI_H
+#define SDEI_H
 
 #include <spinlock.h>
 #include <utils_def.h>
 
 /* Range 0xC4000020 - 0xC400003F reserved for SDE 64bit smc calls */
-#define SDEI_VERSION				0xC4000020
-#define SDEI_EVENT_REGISTER			0xC4000021
-#define SDEI_EVENT_ENABLE			0xC4000022
-#define SDEI_EVENT_DISABLE			0xC4000023
-#define SDEI_EVENT_CONTEXT			0xC4000024
-#define SDEI_EVENT_COMPLETE			0xC4000025
-#define SDEI_EVENT_COMPLETE_AND_RESUME		0xC4000026
-
-#define SDEI_EVENT_UNREGISTER			0xC4000027
-#define SDEI_EVENT_STATUS			0xC4000028
-#define SDEI_EVENT_GET_INFO			0xC4000029
-#define SDEI_EVENT_ROUTING_SET			0xC400002A
-#define SDEI_PE_MASK				0xC400002B
-#define SDEI_PE_UNMASK				0xC400002C
-
-#define SDEI_INTERRUPT_BIND			0xC400002D
-#define SDEI_INTERRUPT_RELEASE			0xC400002E
-#define SDEI_EVENT_SIGNAL			0xC400002F
-#define SDEI_FEATURES				0xC4000030
-#define SDEI_PRIVATE_RESET			0xC4000031
-#define SDEI_SHARED_RESET			0xC4000032
+#define SDEI_VERSION				0xC4000020U
+#define SDEI_EVENT_REGISTER			0xC4000021U
+#define SDEI_EVENT_ENABLE			0xC4000022U
+#define SDEI_EVENT_DISABLE			0xC4000023U
+#define SDEI_EVENT_CONTEXT			0xC4000024U
+#define SDEI_EVENT_COMPLETE			0xC4000025U
+#define SDEI_EVENT_COMPLETE_AND_RESUME		0xC4000026U
+
+#define SDEI_EVENT_UNREGISTER			0xC4000027U
+#define SDEI_EVENT_STATUS			0xC4000028U
+#define SDEI_EVENT_GET_INFO			0xC4000029U
+#define SDEI_EVENT_ROUTING_SET			0xC400002AU
+#define SDEI_PE_MASK				0xC400002BU
+#define SDEI_PE_UNMASK				0xC400002CU
+
+#define SDEI_INTERRUPT_BIND			0xC400002DU
+#define SDEI_INTERRUPT_RELEASE			0xC400002EU
+#define SDEI_EVENT_SIGNAL			0xC400002FU
+#define SDEI_FEATURES				0xC4000030U
+#define SDEI_PRIVATE_RESET			0xC4000031U
+#define SDEI_SHARED_RESET			0xC4000032U
 
 /* SDEI_EVENT_REGISTER flags */
-#define SDEI_REGF_RM_ANY	0
-#define SDEI_REGF_RM_PE		1
+#define SDEI_REGF_RM_ANY	0ULL
+#define SDEI_REGF_RM_PE		1ULL
 
 /* SDEI_EVENT_COMPLETE status flags */
-#define SDEI_EV_HANDLED		0
-#define SDEI_EV_FAILED		1
-
-/* SDE event status values in bit position */
-#define SDEI_STATF_REGISTERED		0
-#define SDEI_STATF_ENABLED		1
-#define SDEI_STATF_RUNNING		2
+#define SDEI_EV_HANDLED		0U
+#define SDEI_EV_FAILED		1U
 
 /* Internal: SDEI flag bit positions */
-#define _SDEI_MAPF_DYNAMIC_SHIFT	1
-#define _SDEI_MAPF_BOUND_SHIFT		2
-#define _SDEI_MAPF_SIGNALABLE_SHIFT	3
-#define _SDEI_MAPF_PRIVATE_SHIFT	4
-#define _SDEI_MAPF_CRITICAL_SHIFT	5
-#define _SDEI_MAPF_EXPLICIT_SHIFT	6
+#define SDEI_MAPF_DYNAMIC_SHIFT_	1U
+#define SDEI_MAPF_BOUND_SHIFT_		2U
+#define SDEI_MAPF_SIGNALABLE_SHIFT_	3U
+#define SDEI_MAPF_PRIVATE_SHIFT_	4U
+#define SDEI_MAPF_CRITICAL_SHIFT_	5U
+#define SDEI_MAPF_EXPLICIT_SHIFT_	6U
 
 /* SDEI event 0 */
 #define SDEI_EVENT_0	0
 
 /* Placeholder interrupt for dynamic mapping */
-#define SDEI_DYN_IRQ	0
+#define SDEI_DYN_IRQ	0U
 
 /* SDEI flags */
 
@@ -80,20 +75,20 @@
  *
  * See also the is_map_bound() macro.
  */
-#define SDEI_MAPF_DYNAMIC	BIT(_SDEI_MAPF_DYNAMIC_SHIFT)
-#define SDEI_MAPF_BOUND		BIT(_SDEI_MAPF_BOUND_SHIFT)
-#define SDEI_MAPF_EXPLICIT	BIT(_SDEI_MAPF_EXPLICIT_SHIFT)
+#define SDEI_MAPF_DYNAMIC	BIT(SDEI_MAPF_DYNAMIC_SHIFT_)
+#define SDEI_MAPF_BOUND		BIT(SDEI_MAPF_BOUND_SHIFT_)
+#define SDEI_MAPF_EXPLICIT	BIT(SDEI_MAPF_EXPLICIT_SHIFT_)
 
-#define SDEI_MAPF_SIGNALABLE	BIT(_SDEI_MAPF_SIGNALABLE_SHIFT)
-#define SDEI_MAPF_PRIVATE	BIT(_SDEI_MAPF_PRIVATE_SHIFT)
+#define SDEI_MAPF_SIGNALABLE	BIT(SDEI_MAPF_SIGNALABLE_SHIFT_)
+#define SDEI_MAPF_PRIVATE	BIT(SDEI_MAPF_PRIVATE_SHIFT_)
 
 #define SDEI_MAPF_NORMAL	0
-#define SDEI_MAPF_CRITICAL	BIT(_SDEI_MAPF_CRITICAL_SHIFT)
+#define SDEI_MAPF_CRITICAL	BIT(SDEI_MAPF_CRITICAL_SHIFT_)
 
 /* Indices of private and shared mappings */
-#define _SDEI_MAP_IDX_PRIV	0
-#define _SDEI_MAP_IDX_SHRD	1
-#define _SDEI_MAP_IDX_MAX	2
+#define SDEI_MAP_IDX_PRIV_	0U
+#define SDEI_MAP_IDX_SHRD_	1U
+#define SDEI_MAP_IDX_MAX_	2U
 
 /* The macros below are used to identify SDEI calls from the SMC function ID */
 #define SDEI_FID_MASK		U(0xffe0)
@@ -104,22 +99,22 @@
 
 #define SDEI_EVENT_MAP(_event, _intr, _flags) \
 	{ \
-		.ev_num = _event, \
-		.intr = _intr, \
-		.map_flags = _flags \
+		.ev_num = (_event), \
+		.intr = (_intr), \
+		.map_flags = (_flags) \
 	}
 
 #define SDEI_SHARED_EVENT(_event, _intr, _flags) \
 	SDEI_EVENT_MAP(_event, _intr, _flags)
 
 #define SDEI_PRIVATE_EVENT(_event, _intr, _flags) \
-	SDEI_EVENT_MAP(_event, _intr, _flags | SDEI_MAPF_PRIVATE)
+	SDEI_EVENT_MAP(_event, _intr, (_flags) | SDEI_MAPF_PRIVATE)
 
 #define SDEI_DEFINE_EVENT_0(_intr) \
-	SDEI_PRIVATE_EVENT(SDEI_EVENT_0, _intr, SDEI_MAPF_SIGNALABLE)
+	SDEI_PRIVATE_EVENT(SDEI_EVENT_0, (_intr), SDEI_MAPF_SIGNALABLE)
 
 #define SDEI_EXPLICIT_EVENT(_event, _pri) \
-	SDEI_EVENT_MAP(_event, 0, _pri | SDEI_MAPF_EXPLICIT | SDEI_MAPF_PRIVATE)
+	SDEI_EVENT_MAP((_event), 0, (_pri) | SDEI_MAPF_EXPLICIT | SDEI_MAPF_PRIVATE)
 
 /*
  * Declare shared and private entries for each core. Also declare a global
@@ -133,12 +128,12 @@
 		[PLATFORM_CORE_COUNT * ARRAY_SIZE(_private)]; \
 	sdei_entry_t sdei_shared_event_table[ARRAY_SIZE(_shared)]; \
 	const sdei_mapping_t sdei_global_mappings[] = { \
-		[_SDEI_MAP_IDX_PRIV] = { \
-			.map = _private, \
+		[SDEI_MAP_IDX_PRIV_] = { \
+			.map = (_private), \
 			.num_maps = ARRAY_SIZE(_private) \
 		}, \
-		[_SDEI_MAP_IDX_SHRD] = { \
-			.map = _shared, \
+		[SDEI_MAP_IDX_SHRD_] = { \
+			.map = (_shared), \
 			.num_maps = ARRAY_SIZE(_shared) \
 		}, \
 	}
@@ -185,4 +180,4 @@ void sdei_init(void);
 /* Public API to dispatch an event to Normal world */
 int sdei_dispatch_event(int ev_num);
 
-#endif /* __SDEI_H__ */
+#endif /* SDEI_H */
diff --git a/services/std_svc/sdei/sdei_event.c b/services/std_svc/sdei/sdei_event.c
index bf0e779d0..ec69b9d27 100644
--- a/services/std_svc/sdei/sdei_event.c
+++ b/services/std_svc/sdei/sdei_event.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2017-2018, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -21,7 +21,8 @@ sdei_entry_t *get_event_entry(sdei_ev_map_t *map)
 {
 	const sdei_mapping_t *mapping;
 	sdei_entry_t *cpu_priv_base;
-	unsigned int idx, base_idx;
+	unsigned int base_idx;
+	long int idx;
 
 	if (is_event_private(map)) {
 		/*
@@ -32,7 +33,7 @@ sdei_entry_t *get_event_entry(sdei_ev_map_t *map)
 		idx = MAP_OFF(map, mapping);
 
 		/* Base of private mappings for this CPU */
-		base_idx = plat_my_core_pos() * mapping->num_maps;
+		base_idx = plat_my_core_pos() * ((unsigned int) mapping->num_maps);
 		cpu_priv_base = &sdei_private_event_table[base_idx];
 
 		/*
@@ -52,7 +53,7 @@ sdei_entry_t *get_event_entry(sdei_ev_map_t *map)
  * Find event mapping for a given interrupt number: On success, returns pointer
  * to the event mapping. On error, returns NULL.
  */
-sdei_ev_map_t *find_event_map_by_intr(int intr_num, int shared)
+sdei_ev_map_t *find_event_map_by_intr(unsigned int intr_num, bool shared)
 {
 	const sdei_mapping_t *mapping;
 	sdei_ev_map_t *map;
diff --git a/services/std_svc/sdei/sdei_intr_mgmt.c b/services/std_svc/sdei/sdei_intr_mgmt.c
index a37188ac4..dd4ef307a 100644
--- a/services/std_svc/sdei/sdei_intr_mgmt.c
+++ b/services/std_svc/sdei/sdei_intr_mgmt.c
@@ -16,17 +16,14 @@
 #include <string.h>
 #include "sdei_private.h"
 
-#define PE_MASKED	1
-#define PE_NOT_MASKED	0
-
 /* x0-x17 GPREGS context */
-#define SDEI_SAVED_GPREGS	18
+#define SDEI_SAVED_GPREGS	18U
 
 /* Maximum preemption nesting levels: Critical priority and Normal priority */
-#define MAX_EVENT_NESTING	2
+#define MAX_EVENT_NESTING	2U
 
 /* Per-CPU SDEI state access macro */
-#define sdei_get_this_pe_state()	(&sdei_cpu_state[plat_my_core_pos()])
+#define sdei_get_this_pe_state()	(&cpu_state[plat_my_core_pos()])
 
 /* Structure to store information about an outstanding dispatch */
 typedef struct sdei_dispatch_context {
@@ -48,31 +45,33 @@ typedef struct sdei_dispatch_context {
 typedef struct sdei_cpu_state {
 	sdei_dispatch_context_t dispatch_stack[MAX_EVENT_NESTING];
 	unsigned short stack_top; /* Empty ascending */
-	unsigned int pe_masked:1;
-	unsigned int pending_enables:1;
+	bool pe_masked;
+	bool pending_enables;
 } sdei_cpu_state_t;
 
 /* SDEI states for all cores in the system */
-static sdei_cpu_state_t sdei_cpu_state[PLATFORM_CORE_COUNT];
+static sdei_cpu_state_t cpu_state[PLATFORM_CORE_COUNT];
 
-unsigned int sdei_pe_mask(void)
+int64_t sdei_pe_mask(void)
 {
-	unsigned int ret;
+	int64_t ret = 0;
 	sdei_cpu_state_t *state = sdei_get_this_pe_state();
 
 	/*
 	 * Return value indicates whether this call had any effect in the mask
 	 * status of this PE.
 	 */
-	ret = (state->pe_masked ^ PE_MASKED);
-	state->pe_masked = PE_MASKED;
+	if (!state->pe_masked) {
+		state->pe_masked = true;
+		ret = 1;
+	}
 
 	return ret;
 }
 
 void sdei_pe_unmask(void)
 {
-	int i;
+	unsigned int i;
 	sdei_ev_map_t *map;
 	sdei_entry_t *se;
 	sdei_cpu_state_t *state = sdei_get_this_pe_state();
@@ -95,8 +94,7 @@ void sdei_pe_unmask(void)
 			se = get_event_entry(map);
 
 			sdei_map_lock(map);
-			if (is_map_bound(map) &&
-					GET_EV_STATE(se, ENABLED) &&
+			if (is_map_bound(map) && GET_EV_STATE(se, ENABLED) &&
 					(se->reg_flags == SDEI_REGF_RM_PE) &&
 					(se->affinity == my_mpidr)) {
 				plat_ic_enable_interrupt(map->intr);
@@ -105,8 +103,8 @@ void sdei_pe_unmask(void)
 		}
 	}
 
-	state->pending_enables = 0;
-	state->pe_masked = PE_NOT_MASKED;
+	state->pending_enables = false;
+	state->pe_masked = false;
 }
 
 /* Push a dispatch context to the dispatch stack */
@@ -129,7 +127,7 @@ static sdei_dispatch_context_t *pop_dispatch(void)
 {
 	sdei_cpu_state_t *state = sdei_get_this_pe_state();
 
-	if (state->stack_top == 0)
+	if (state->stack_top == 0U)
 		return NULL;
 
 	assert(state->stack_top <= MAX_EVENT_NESTING);
@@ -144,27 +142,27 @@ static sdei_dispatch_context_t *get_outstanding_dispatch(void)
 {
 	sdei_cpu_state_t *state = sdei_get_this_pe_state();
 
-	if (state->stack_top == 0)
+	if (state->stack_top == 0U)
 		return NULL;
 
 	assert(state->stack_top <= MAX_EVENT_NESTING);
 
-	return &state->dispatch_stack[state->stack_top - 1];
+	return &state->dispatch_stack[state->stack_top - 1U];
 }
 
 static sdei_dispatch_context_t *save_event_ctx(sdei_ev_map_t *map,
 		void *tgt_ctx)
 {
 	sdei_dispatch_context_t *disp_ctx;
-	gp_regs_t *tgt_gpregs;
-	el3_state_t *tgt_el3;
+	const gp_regs_t *tgt_gpregs;
+	const el3_state_t *tgt_el3;
 
-	assert(tgt_ctx);
+	assert(tgt_ctx != NULL);
 	tgt_gpregs = get_gpregs_ctx(tgt_ctx);
 	tgt_el3 = get_el3state_ctx(tgt_ctx);
 
 	disp_ctx = push_dispatch();
-	assert(disp_ctx);
+	assert(disp_ctx != NULL);
 	disp_ctx->map = map;
 
 	/* Save general purpose and exception registers */
@@ -175,12 +173,12 @@ static sdei_dispatch_context_t *save_event_ctx(sdei_ev_map_t *map,
 	return disp_ctx;
 }
 
-static void restore_event_ctx(sdei_dispatch_context_t *disp_ctx, void *tgt_ctx)
+static void restore_event_ctx(const sdei_dispatch_context_t *disp_ctx, void *tgt_ctx)
 {
 	gp_regs_t *tgt_gpregs;
 	el3_state_t *tgt_el3;
 
-	assert(tgt_ctx);
+	assert(tgt_ctx != NULL);
 	tgt_gpregs = get_gpregs_ctx(tgt_ctx);
 	tgt_el3 = get_el3state_ctx(tgt_ctx);
 
@@ -226,7 +224,7 @@ static cpu_context_t *restore_and_resume_ns_context(void)
 	cm_set_next_eret_context(NON_SECURE);
 
 	ns_ctx = cm_get_context(NON_SECURE);
-	assert(ns_ctx);
+	assert(ns_ctx != NULL);
 
 	return ns_ctx;
 }
@@ -251,7 +249,7 @@ static void setup_ns_dispatch(sdei_ev_map_t *map, sdei_entry_t *se,
 	 * - x2: Interrupted PC
 	 * - x3: Interrupted SPSR
 	 */
-	SMC_SET_GP(ctx, CTX_GPREG_X0, map->ev_num);
+	SMC_SET_GP(ctx, CTX_GPREG_X0, (uint64_t) map->ev_num);
 	SMC_SET_GP(ctx, CTX_GPREG_X1, se->arg);
 	SMC_SET_GP(ctx, CTX_GPREG_X2, disp_ctx->elr_el3);
 	SMC_SET_GP(ctx, CTX_GPREG_X3, disp_ctx->spsr_el3);
@@ -286,7 +284,7 @@ static void handle_masked_trigger(sdei_ev_map_t *map, sdei_entry_t *se,
 		sdei_cpu_state_t *state, unsigned int intr_raw)
 {
 	uint64_t my_mpidr __unused = (read_mpidr_el1() & MPIDR_AFFINITY_MASK);
-	int disable = 0;
+	bool disable = false;
 
 	/* Nothing to do for event 0 */
 	if (map->ev_num == SDEI_EVENT_0)
@@ -297,18 +295,17 @@ static void handle_masked_trigger(sdei_ev_map_t *map, sdei_entry_t *se,
 	 * this CPU, we disable interrupt, leave the interrupt pending, and do
 	 * EOI.
 	 */
-	if (is_event_private(map)) {
-		disable = 1;
-	} else if (se->reg_flags == SDEI_REGF_RM_PE) {
+	if (is_event_private(map) || (se->reg_flags == SDEI_REGF_RM_PE))
+		disable = true;
+
+	if (se->reg_flags == SDEI_REGF_RM_PE)
 		assert(se->affinity == my_mpidr);
-		disable = 1;
-	}
 
 	if (disable) {
 		plat_ic_disable_interrupt(map->intr);
 		plat_ic_set_interrupt_pending(map->intr);
 		plat_ic_end_of_interrupt(intr_raw);
-		state->pending_enables = 1;
+		state->pending_enables = true;
 
 		return;
 	}
@@ -321,7 +318,7 @@ static void handle_masked_trigger(sdei_ev_map_t *map, sdei_entry_t *se,
 	 * Therefore, we set the interrupt back pending so as to give other
 	 * suitable PEs a chance of handling it.
 	 */
-	assert(plat_ic_is_spi(map->intr));
+	assert(plat_ic_is_spi(map->intr) != 0);
 	plat_ic_set_interrupt_pending(map->intr);
 
 	/*
@@ -344,11 +341,12 @@ int sdei_intr_handler(uint32_t intr_raw, uint32_t flags, void *handle,
 	sdei_entry_t *se;
 	cpu_context_t *ctx;
 	sdei_ev_map_t *map;
-	sdei_dispatch_context_t *disp_ctx;
+	const sdei_dispatch_context_t *disp_ctx;
 	unsigned int sec_state;
 	sdei_cpu_state_t *state;
 	uint32_t intr;
 	struct jmpbuf dispatch_jmp;
+	const uint64_t mpidr = read_mpidr_el1();
 
 	/*
 	 * To handle an event, the following conditions must be true:
@@ -374,8 +372,8 @@ int sdei_intr_handler(uint32_t intr_raw, uint32_t flags, void *handle,
 	 * this interrupt
 	 */
 	intr = plat_ic_get_interrupt_id(intr_raw);
-	map = find_event_map_by_intr(intr, plat_ic_is_spi(intr));
-	if (!map) {
+	map = find_event_map_by_intr(intr, (plat_ic_is_spi(intr) != 0));
+	if (map == NULL) {
 		ERROR("No SDEI map for interrupt %u\n", intr);
 		panic();
 	}
@@ -389,13 +387,13 @@ int sdei_intr_handler(uint32_t intr_raw, uint32_t flags, void *handle,
 	se = get_event_entry(map);
 	state = sdei_get_this_pe_state();
 
-	if (state->pe_masked == PE_MASKED) {
+	if (state->pe_masked) {
 		/*
 		 * Interrupts received while this PE was masked can't be
 		 * dispatched.
 		 */
-		SDEI_LOG("interrupt %u on %lx while PE masked\n", map->intr,
-				read_mpidr_el1());
+		SDEI_LOG("interrupt %u on %llx while PE masked\n", map->intr,
+				mpidr);
 		if (is_event_shared(map))
 			sdei_map_lock(map);
 
@@ -416,8 +414,7 @@ int sdei_intr_handler(uint32_t intr_raw, uint32_t flags, void *handle,
 
 	/* Assert shared event routed to this PE had been configured so */
 	if (is_event_shared(map) && (se->reg_flags == SDEI_REGF_RM_PE)) {
-		assert(se->affinity ==
-				(read_mpidr_el1() & MPIDR_AFFINITY_MASK));
+		assert(se->affinity == (mpidr & MPIDR_AFFINITY_MASK));
 	}
 
 	if (!can_sdei_state_trans(se, DO_DISPATCH)) {
@@ -451,7 +448,7 @@ int sdei_intr_handler(uint32_t intr_raw, uint32_t flags, void *handle,
 		 * dispatch, assert the latter is a Normal dispatch. Critical
 		 * events can preempt an outstanding Normal event dispatch.
 		 */
-		if (disp_ctx)
+		if (disp_ctx != NULL)
 			assert(is_event_normal(disp_ctx->map));
 	} else {
 		/*
@@ -467,9 +464,8 @@ int sdei_intr_handler(uint32_t intr_raw, uint32_t flags, void *handle,
 	if (is_event_shared(map))
 		sdei_map_unlock(map);
 
-	SDEI_LOG("ACK %lx, ev:%d ss:%d spsr:%lx ELR:%lx\n", read_mpidr_el1(),
-			map->ev_num, sec_state, read_spsr_el3(),
-			read_elr_el3());
+	SDEI_LOG("ACK %llx, ev:%d ss:%d spsr:%lx ELR:%lx\n", mpidr, map->ev_num,
+			sec_state, read_spsr_el3(), read_elr_el3());
 
 	ctx = handle;
 
@@ -497,7 +493,7 @@ int sdei_intr_handler(uint32_t intr_raw, uint32_t flags, void *handle,
 	 * Non-secure context was fully saved before dispatch, and has been
 	 * returned to its pre-dispatch state.
 	 */
-	if ((sec_state == SECURE) && (ehf_is_ns_preemption_allowed() == 0))
+	if ((sec_state == SECURE) && (ehf_is_ns_preemption_allowed() == 0U))
 		restore_and_resume_secure_context();
 
 	/*
@@ -539,7 +535,7 @@ int sdei_dispatch_event(int ev_num)
 
 	/* Can't dispatch if events are masked on this PE */
 	state = sdei_get_this_pe_state();
-	if (state->pe_masked == PE_MASKED)
+	if (state->pe_masked)
 		return -1;
 
 	/* Event 0 can't be dispatched */
@@ -548,7 +544,7 @@ int sdei_dispatch_event(int ev_num)
 
 	/* Locate mapping corresponding to this event */
 	map = find_event_map(ev_num);
-	if (!map)
+	if (map == NULL)
 		return -1;
 
 	/* Only explicit events can be dispatched */
@@ -557,7 +553,7 @@ int sdei_dispatch_event(int ev_num)
 
 	/* Examine state of dispatch stack */
 	disp_ctx = get_outstanding_dispatch();
-	if (disp_ctx) {
+	if (disp_ctx != NULL) {
 		/*
 		 * There's an outstanding dispatch. If the outstanding dispatch
 		 * is critical, no more dispatches are possible.
@@ -606,7 +602,7 @@ static void end_sdei_synchronous_dispatch(struct jmpbuf *buffer)
 	longjmp(buffer);
 }
 
-int sdei_event_complete(int resume, uint64_t pc)
+int sdei_event_complete(bool resume, uint64_t pc)
 {
 	sdei_dispatch_context_t *disp_ctx;
 	sdei_entry_t *se;
@@ -617,7 +613,7 @@ int sdei_event_complete(int resume, uint64_t pc)
 
 	/* Return error if called without an active event */
 	disp_ctx = get_outstanding_dispatch();
-	if (!disp_ctx)
+	if (disp_ctx == NULL)
 		return SDEI_EDENY;
 
 	/* Validate resumption point */
@@ -625,7 +621,7 @@ int sdei_event_complete(int resume, uint64_t pc)
 		return SDEI_EDENY;
 
 	map = disp_ctx->map;
-	assert(map);
+	assert(map != NULL);
 	se = get_event_entry(map);
 
 	act = resume ? DO_COMPLETE_RESUME : DO_COMPLETE;
@@ -636,7 +632,7 @@ int sdei_event_complete(int resume, uint64_t pc)
 	}
 
 	/* Having done sanity checks, pop dispatch */
-	pop_dispatch();
+	(void) pop_dispatch();
 
 	SDEI_LOG("EOI:%lx, %d spsr:%lx elr:%lx\n", read_mpidr_el1(),
 			map->ev_num, read_spsr_el3(), read_elr_el3());
@@ -684,7 +680,7 @@ int sdei_event_complete(int resume, uint64_t pc)
 	return 0;
 }
 
-int sdei_event_context(void *handle, unsigned int param)
+int64_t sdei_event_context(void *handle, unsigned int param)
 {
 	sdei_dispatch_context_t *disp_ctx;
 
@@ -693,10 +689,10 @@ int sdei_event_context(void *handle, unsigned int param)
 
 	/* Get outstanding dispatch on this CPU */
 	disp_ctx = get_outstanding_dispatch();
-	if (!disp_ctx)
+	if (disp_ctx == NULL)
 		return SDEI_EDENY;
 
-	assert(disp_ctx->map);
+	assert(disp_ctx->map != NULL);
 
 	if (!can_sdei_state_trans(get_event_entry(disp_ctx->map), DO_CONTEXT))
 		return SDEI_EDENY;
@@ -706,5 +702,5 @@ int sdei_event_context(void *handle, unsigned int param)
 	 * which can complete the event
 	 */
 
-	return disp_ctx->x[param];
+	return (int64_t) disp_ctx->x[param];
 }
diff --git a/services/std_svc/sdei/sdei_main.c b/services/std_svc/sdei/sdei_main.c
index 28afc1d4b..9b78d7fbc 100644
--- a/services/std_svc/sdei/sdei_main.c
+++ b/services/std_svc/sdei/sdei_main.c
@@ -22,14 +22,12 @@
 #include <utils.h>
 #include "sdei_private.h"
 
-#define MAJOR_VERSION	1
-#define MINOR_VERSION	0
-#define VENDOR_VERSION	0
+#define MAJOR_VERSION	1ULL
+#define MINOR_VERSION	0ULL
+#define VENDOR_VERSION	0ULL
 
 #define MAKE_SDEI_VERSION(_major, _minor, _vendor) \
-	((((unsigned long long)(_major)) << 48) | \
-	 (((unsigned long long)(_minor)) << 32) | \
-	 (_vendor))
+	((((_major)) << 48ULL) | (((_minor)) << 32ULL) | (_vendor))
 
 #define LOWEST_INTR_PRIORITY		0xff
 
@@ -47,7 +45,7 @@ static void init_map(sdei_ev_map_t *map)
 }
 
 /* Convert mapping to SDEI class */
-sdei_class_t map_to_class(sdei_ev_map_t *map)
+static sdei_class_t map_to_class(sdei_ev_map_t *map)
 {
 	return is_event_critical(map) ? SDEI_CRITICAL : SDEI_NORMAL;
 }
@@ -64,7 +62,7 @@ static void clear_event_entries(sdei_entry_t *se)
 /* Perform CPU-specific state initialisation */
 static void *sdei_cpu_on_init(const void *arg)
 {
-	int i;
+	unsigned int i;
 	sdei_ev_map_t *map;
 	sdei_entry_t *se;
 
@@ -78,15 +76,16 @@ static void *sdei_cpu_on_init(const void *arg)
 	SDEI_LOG("Private events initialized on %lx\n", read_mpidr_el1());
 
 	/* All PEs start with SDEI events masked */
-	sdei_pe_mask();
+	(void) sdei_pe_mask();
 
-	return 0;
+	return NULL;
 }
 
 /* Initialise an SDEI class */
-void sdei_class_init(sdei_class_t class)
+static void sdei_class_init(sdei_class_t class)
 {
-	unsigned int i, zero_found __unused = 0;
+	unsigned int i;
+	bool zero_found __unused = false;
 	int ev_num_so_far __unused;
 	sdei_ev_map_t *map;
 
@@ -126,7 +125,7 @@ void sdei_class_init(sdei_class_t class)
 			num_dyn_shrd_slots++;
 		} else {
 			/* Shared mappings must be bound to shared interrupt */
-			assert(plat_ic_is_spi(map->intr));
+			assert(plat_ic_is_spi(map->intr) != 0);
 			set_map_bound(map);
 		}
 
@@ -143,7 +142,7 @@ void sdei_class_init(sdei_class_t class)
 		ev_num_so_far = map->ev_num;
 
 		if (map->ev_num == SDEI_EVENT_0) {
-			zero_found = 1;
+			zero_found = true;
 
 			/* Event 0 must be a Secure SGI */
 			assert(is_secure_sgi(map->intr));
@@ -197,7 +196,7 @@ void sdei_class_init(sdei_class_t class)
 				 * Private mappings must be bound to private
 				 * interrupt.
 				 */
-				assert(plat_ic_is_ppi(map->intr));
+				assert(plat_ic_is_ppi((unsigned) map->intr) != 0);
 				set_map_bound(map);
 			}
 		}
@@ -208,7 +207,7 @@ void sdei_class_init(sdei_class_t class)
 	/* Ensure event 0 is in the mapping */
 	assert(zero_found);
 
-	sdei_cpu_on_init(NULL);
+	(void) sdei_cpu_on_init(NULL);
 }
 
 /* SDEI dispatcher initialisation */
@@ -236,7 +235,7 @@ static void set_sdei_entry(sdei_entry_t *se, uint64_t ep, uint64_t arg,
 	se->reg_flags = flags;
 }
 
-static unsigned long long sdei_version(void)
+static uint64_t sdei_version(void)
 {
 	return MAKE_SDEI_VERSION(MAJOR_VERSION, MINOR_VERSION, VENDOR_VERSION);
 }
@@ -263,17 +262,18 @@ static int validate_flags(uint64_t flags, uint64_t mpidr)
 /* Set routing of an SDEI event */
 static int sdei_event_routing_set(int ev_num, uint64_t flags, uint64_t mpidr)
 {
-	int ret, routing;
+	int ret;
+	unsigned int routing;
 	sdei_ev_map_t *map;
 	sdei_entry_t *se;
 
 	ret = validate_flags(flags, mpidr);
-	if (ret)
+	if (ret != 0)
 		return ret;
 
 	/* Check if valid event number */
 	map = find_event_map(ev_num);
-	if (!map)
+	if (map == NULL)
 		return SDEI_EINVAL;
 
 	/* The event must not be private */
@@ -295,11 +295,11 @@ static int sdei_event_routing_set(int ev_num, uint64_t flags, uint64_t mpidr)
 	}
 
 	/* Choose appropriate routing */
-	routing = (flags == SDEI_REGF_RM_ANY) ? INTR_ROUTING_MODE_ANY :
-		INTR_ROUTING_MODE_PE;
+	routing = (unsigned int) ((flags == SDEI_REGF_RM_ANY) ?
+		INTR_ROUTING_MODE_ANY : INTR_ROUTING_MODE_PE);
 
 	/* Update event registration flag */
-	se->reg_flags = flags;
+	se->reg_flags = (unsigned int) flags;
 
 	/*
 	 * ROUTING_SET is permissible only when event composite state is
@@ -315,24 +315,27 @@ finish:
 }
 
 /* Register handler and argument for an SDEI event */
-static int sdei_event_register(int ev_num, uint64_t ep, uint64_t arg,
+static int64_t sdei_event_register(int ev_num, uint64_t ep, uint64_t arg,
 		uint64_t flags, uint64_t mpidr)
 {
 	int ret;
+	unsigned int routing;
 	sdei_entry_t *se;
 	sdei_ev_map_t *map;
 	sdei_state_t backup_state;
 
-	if (!ep || (plat_sdei_validate_entry_point(ep, sdei_client_el()) != 0))
+	if ((ep == 0U) || (plat_sdei_validate_entry_point(
+					ep, sdei_client_el()) != 0)) {
 		return SDEI_EINVAL;
+	}
 
 	ret = validate_flags(flags, mpidr);
-	if (ret)
+	if (ret != 0)
 		return ret;
 
 	/* Check if valid event number */
 	map = find_event_map(ev_num);
-	if (!map)
+	if (map == NULL)
 		return SDEI_EINVAL;
 
 	/* Private events always target the PE */
@@ -371,7 +374,7 @@ static int sdei_event_register(int ev_num, uint64_t ep, uint64_t arg,
 
 	if (is_map_bound(map)) {
 		/* Meanwhile, did any PE ACK the interrupt? */
-		if (plat_ic_get_interrupt_active(map->intr))
+		if (plat_ic_get_interrupt_active(map->intr) != 0U)
 			goto fallback;
 
 		/* The interrupt must currently owned by Non-secure */
@@ -404,16 +407,15 @@ static int sdei_event_register(int ev_num, uint64_t ep, uint64_t arg,
 		 * already ensure that shared events get bound to SPIs.
 		 */
 		if (is_event_shared(map)) {
-			plat_ic_set_spi_routing(map->intr,
-					((flags == SDEI_REGF_RM_ANY) ?
-					 INTR_ROUTING_MODE_ANY :
-					 INTR_ROUTING_MODE_PE),
+			routing = (unsigned int) ((flags == SDEI_REGF_RM_ANY) ?
+				INTR_ROUTING_MODE_ANY : INTR_ROUTING_MODE_PE);
+			plat_ic_set_spi_routing(map->intr, routing,
 					(u_register_t) mpidr);
 		}
 	}
 
 	/* Populate event entries */
-	set_sdei_entry(se, ep, arg, flags, mpidr);
+	set_sdei_entry(se, ep, arg, (unsigned int) flags, mpidr);
 
 	/* Increment register count */
 	map->reg_count++;
@@ -432,15 +434,16 @@ fallback:
 }
 
 /* Enable SDEI event */
-static int sdei_event_enable(int ev_num)
+static int64_t sdei_event_enable(int ev_num)
 {
 	sdei_ev_map_t *map;
 	sdei_entry_t *se;
-	int ret, before, after;
+	int ret;
+	bool before, after;
 
 	/* Check if valid event number */
 	map = find_event_map(ev_num);
-	if (!map)
+	if (map == NULL)
 		return SDEI_EINVAL;
 
 	se = get_event_entry(map);
@@ -475,11 +478,12 @@ static int sdei_event_disable(int ev_num)
 {
 	sdei_ev_map_t *map;
 	sdei_entry_t *se;
-	int ret, before, after;
+	int ret;
+	bool before, after;
 
 	/* Check if valid event number */
 	map = find_event_map(ev_num);
-	if (!map)
+	if (map == NULL)
 		return SDEI_EINVAL;
 
 	se = get_event_entry(map);
@@ -510,17 +514,18 @@ finish:
 }
 
 /* Query SDEI event information */
-static uint64_t sdei_event_get_info(int ev_num, int info)
+static int64_t sdei_event_get_info(int ev_num, int info)
 {
 	sdei_entry_t *se;
 	sdei_ev_map_t *map;
 
-	unsigned int flags, registered;
+	uint64_t flags;
+	bool registered;
 	uint64_t affinity;
 
 	/* Check if valid event number */
 	map = find_event_map(ev_num);
-	if (!map)
+	if (map == NULL)
 		return SDEI_EINVAL;
 
 	se = get_event_entry(map);
@@ -576,7 +581,7 @@ static int sdei_event_unregister(int ev_num)
 
 	/* Check if valid event number */
 	map = find_event_map(ev_num);
-	if (!map)
+	if (map == NULL)
 		return SDEI_EINVAL;
 
 	se = get_event_entry(map);
@@ -648,7 +653,7 @@ static int sdei_event_status(int ev_num)
 
 	/* Check if valid event number */
 	map = find_event_map(ev_num);
-	if (!map)
+	if (map == NULL)
 		return SDEI_EINVAL;
 
 	se = get_event_entry(map);
@@ -662,27 +667,27 @@ static int sdei_event_status(int ev_num)
 	if (is_event_shared(map))
 		sdei_map_unlock(map);
 
-	return state;
+	return (int) state;
 }
 
 /* Bind an SDEI event to an interrupt */
-static int sdei_interrupt_bind(int intr_num)
+static int sdei_interrupt_bind(unsigned int intr_num)
 {
 	sdei_ev_map_t *map;
-	int retry = 1, shared_mapping;
+	bool retry = true, shared_mapping;
 
 	/* SGIs are not allowed to be bound */
-	if (plat_ic_is_sgi(intr_num))
+	if (plat_ic_is_sgi(intr_num) != 0)
 		return SDEI_EINVAL;
 
-	shared_mapping = plat_ic_is_spi(intr_num);
+	shared_mapping = (plat_ic_is_spi(intr_num) != 0);
 	do {
 		/*
 		 * Bail out if there is already an event for this interrupt,
 		 * either platform-defined or dynamic.
 		 */
 		map = find_event_map_by_intr(intr_num, shared_mapping);
-		if (map) {
+		if (map != NULL) {
 			if (is_map_dynamic(map)) {
 				if (is_map_bound(map)) {
 					/*
@@ -703,7 +708,7 @@ static int sdei_interrupt_bind(int intr_num)
 		 * SDEI_DYN_IRQ.
 		 */
 		map = find_event_map_by_intr(SDEI_DYN_IRQ, shared_mapping);
-		if (!map)
+		if (map == NULL)
 			return SDEI_ENOMEM;
 
 		/* The returned mapping must be dynamic */
@@ -727,7 +732,7 @@ static int sdei_interrupt_bind(int intr_num)
 		if (!is_map_bound(map)) {
 			map->intr = intr_num;
 			set_map_bound(map);
-			retry = 0;
+			retry = false;
 		}
 		sdei_map_unlock(map);
 	} while (retry);
@@ -744,7 +749,7 @@ static int sdei_interrupt_release(int ev_num)
 
 	/* Check if valid event number */
 	map = find_event_map(ev_num);
-	if (!map)
+	if (map == NULL)
 		return SDEI_EINVAL;
 
 	if (!is_map_dynamic(map))
@@ -774,7 +779,7 @@ static int sdei_interrupt_release(int ev_num)
 		 * Deny release if the interrupt is active, which means it's
 		 * probably being acknowledged and handled elsewhere.
 		 */
-		if (plat_ic_get_interrupt_active(map->intr)) {
+		if (plat_ic_get_interrupt_active(map->intr) != 0U) {
 			ret = SDEI_EDENY;
 			goto finish;
 		}
@@ -802,7 +807,8 @@ finish:
 static int sdei_private_reset(void)
 {
 	sdei_ev_map_t *map;
-	int ret = 0, final_ret = 0, i;
+	int ret = 0, final_ret = 0;
+	unsigned int i;
 
 	/* Unregister all private events */
 	for_each_private_map(i, map) {
@@ -824,7 +830,8 @@ static int sdei_shared_reset(void)
 {
 	const sdei_mapping_t *mapping;
 	sdei_ev_map_t *map;
-	int ret = 0, final_ret = 0, i, j;
+	int ret = 0, final_ret = 0;
+	unsigned int i, j;
 
 	/* Unregister all shared events */
 	for_each_shared_map(i, map) {
@@ -867,17 +874,17 @@ static int sdei_shared_reset(void)
 }
 
 /* Send a signal to another SDEI client PE */
-int sdei_signal(int event, uint64_t target_pe)
+static int sdei_signal(int ev_num, uint64_t target_pe)
 {
 	sdei_ev_map_t *map;
 
 	/* Only event 0 can be signalled */
-	if (event != SDEI_EVENT_0)
+	if (ev_num != SDEI_EVENT_0)
 		return SDEI_EINVAL;
 
 	/* Find mapping for event 0 */
 	map = find_event_map(SDEI_EVENT_0);
-	if (!map)
+	if (map == NULL)
 		return SDEI_EINVAL;
 
 	/* The event must be signalable */
@@ -889,20 +896,20 @@ int sdei_signal(int event, uint64_t target_pe)
 		return SDEI_EINVAL;
 
 	/* Raise SGI. Platform will validate target_pe */
-	plat_ic_raise_el3_sgi(map->intr, (u_register_t) target_pe);
+	plat_ic_raise_el3_sgi((int) map->intr, (u_register_t) target_pe);
 
 	return 0;
 }
 
 /* Query SDEI dispatcher features */
-uint64_t sdei_features(unsigned int feature)
+static uint64_t sdei_features(unsigned int feature)
 {
 	if (feature == SDEI_FEATURE_BIND_SLOTS) {
 		return FEATURE_BIND_SLOTS(num_dyn_priv_slots,
 				num_dyn_shrd_slots);
 	}
 
-	return SDEI_EINVAL;
+	return (uint64_t) SDEI_EINVAL;
 }
 
 /* SDEI top level handler for servicing SMCs */
@@ -917,56 +924,59 @@ uint64_t sdei_smc_handler(uint32_t smc_fid,
 {
 
 	uint64_t x5;
-	int ss = get_interrupt_src_ss(flags);
+	unsigned int ss = (unsigned int) get_interrupt_src_ss(flags);
 	int64_t ret;
-	unsigned int resume = 0;
+	bool resume = false;
+	cpu_context_t *ctx = handle;
+	int ev_num = (int) x1;
 
 	if (ss != NON_SECURE)
-		SMC_RET1(handle, SMC_UNK);
+		SMC_RET1(ctx, SMC_UNK);
 
 	/* Verify the caller EL */
 	if (GET_EL(read_spsr_el3()) != sdei_client_el())
-		SMC_RET1(handle, SMC_UNK);
+		SMC_RET1(ctx, SMC_UNK);
 
 	switch (smc_fid) {
 	case SDEI_VERSION:
 		SDEI_LOG("> VER\n");
-		ret = sdei_version();
+		ret = (int64_t) sdei_version();
 		SDEI_LOG("< VER:%llx\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_EVENT_REGISTER:
-		x5 = SMC_GET_GP(handle, CTX_GPREG_X5);
-		SDEI_LOG("> REG(n:%d e:%llx a:%llx f:%x m:%llx)\n", (int) x1,
+		x5 = SMC_GET_GP(ctx, CTX_GPREG_X5);
+		SDEI_LOG("> REG(n:%d e:%llx a:%llx f:%x m:%llx)\n", ev_num,
 				x2, x3, (int) x4, x5);
-		ret = sdei_event_register(x1, x2, x3, x4, x5);
+		ret = sdei_event_register(ev_num, x2, x3, x4, x5);
 		SDEI_LOG("< REG:%lld\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_EVENT_ENABLE:
 		SDEI_LOG("> ENABLE(n:%d)\n", (int) x1);
-		ret = sdei_event_enable(x1);
+		ret = sdei_event_enable(ev_num);
 		SDEI_LOG("< ENABLE:%lld\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_EVENT_DISABLE:
-		SDEI_LOG("> DISABLE(n:%d)\n", (int) x1);
-		ret = sdei_event_disable(x1);
+		SDEI_LOG("> DISABLE(n:%d)\n", ev_num);
+		ret = sdei_event_disable(ev_num);
 		SDEI_LOG("< DISABLE:%lld\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_EVENT_CONTEXT:
 		SDEI_LOG("> CTX(p:%d):%lx\n", (int) x1, read_mpidr_el1());
-		ret = sdei_event_context(handle, x1);
+		ret = sdei_event_context(ctx, (unsigned int) x1);
 		SDEI_LOG("< CTX:%lld\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_EVENT_COMPLETE_AND_RESUME:
-		resume = 1;
+		resume = true;
+		/* Fallthrough */
 
 	case SDEI_EVENT_COMPLETE:
-		SDEI_LOG("> COMPLETE(r:%d sta/ep:%llx):%lx\n", resume, x1,
-				read_mpidr_el1());
+		SDEI_LOG("> COMPLETE(r:%u sta/ep:%llx):%lx\n",
+				(unsigned int) resume, x1, read_mpidr_el1());
 		ret = sdei_event_complete(resume, x1);
 		SDEI_LOG("< COMPLETE:%llx\n", ret);
 
@@ -977,82 +987,82 @@ uint64_t sdei_smc_handler(uint32_t smc_fid,
 		 * shouldn't be modified. We don't return to the caller in this
 		 * case anyway.
 		 */
-		if (ret)
-			SMC_RET1(handle, ret);
+		if (ret != 0)
+			SMC_RET1(ctx, ret);
 
-		SMC_RET0(handle);
+		SMC_RET0(ctx);
 
 	case SDEI_EVENT_STATUS:
-		SDEI_LOG("> STAT(n:%d)\n", (int) x1);
-		ret = sdei_event_status(x1);
+		SDEI_LOG("> STAT(n:%d)\n", ev_num);
+		ret = sdei_event_status(ev_num);
 		SDEI_LOG("< STAT:%lld\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_EVENT_GET_INFO:
-		SDEI_LOG("> INFO(n:%d, %d)\n", (int) x1, (int) x2);
-		ret = sdei_event_get_info(x1, x2);
+		SDEI_LOG("> INFO(n:%d, %d)\n", ev_num, (int) x2);
+		ret = sdei_event_get_info(ev_num, (int) x2);
 		SDEI_LOG("< INFO:%lld\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_EVENT_UNREGISTER:
-		SDEI_LOG("> UNREG(n:%d)\n", (int) x1);
-		ret = sdei_event_unregister(x1);
+		SDEI_LOG("> UNREG(n:%d)\n", ev_num);
+		ret = sdei_event_unregister(ev_num);
 		SDEI_LOG("< UNREG:%lld\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_PE_UNMASK:
 		SDEI_LOG("> UNMASK:%lx\n", read_mpidr_el1());
 		sdei_pe_unmask();
 		SDEI_LOG("< UNMASK:%d\n", 0);
-		SMC_RET1(handle, 0);
+		SMC_RET1(ctx, 0);
 
 	case SDEI_PE_MASK:
 		SDEI_LOG("> MASK:%lx\n", read_mpidr_el1());
 		ret = sdei_pe_mask();
 		SDEI_LOG("< MASK:%lld\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_INTERRUPT_BIND:
 		SDEI_LOG("> BIND(%d)\n", (int) x1);
-		ret = sdei_interrupt_bind(x1);
+		ret = sdei_interrupt_bind((unsigned int) x1);
 		SDEI_LOG("< BIND:%lld\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_INTERRUPT_RELEASE:
-		SDEI_LOG("> REL(%d)\n", (int) x1);
-		ret = sdei_interrupt_release(x1);
+		SDEI_LOG("> REL(%d)\n", ev_num);
+		ret = sdei_interrupt_release(ev_num);
 		SDEI_LOG("< REL:%lld\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_SHARED_RESET:
 		SDEI_LOG("> S_RESET():%lx\n", read_mpidr_el1());
 		ret = sdei_shared_reset();
 		SDEI_LOG("< S_RESET:%lld\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_PRIVATE_RESET:
 		SDEI_LOG("> P_RESET():%lx\n", read_mpidr_el1());
 		ret = sdei_private_reset();
 		SDEI_LOG("< P_RESET:%lld\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_EVENT_ROUTING_SET:
-		SDEI_LOG("> ROUTE_SET(n:%d f:%llx aff:%llx)\n", (int) x1, x2, x3);
-		ret = sdei_event_routing_set(x1, x2, x3);
+		SDEI_LOG("> ROUTE_SET(n:%d f:%llx aff:%llx)\n", ev_num, x2, x3);
+		ret = sdei_event_routing_set(ev_num, x2, x3);
 		SDEI_LOG("< ROUTE_SET:%lld\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_FEATURES:
 		SDEI_LOG("> FTRS(f:%llx)\n", x1);
-		ret = sdei_features(x1);
+		ret = (int64_t) sdei_features((unsigned int) x1);
 		SDEI_LOG("< FTRS:%llx\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	case SDEI_EVENT_SIGNAL:
-		SDEI_LOG("> SIGNAL(e:%llx t:%llx)\n", x1, x2);
-		ret = sdei_signal(x1, x2);
+		SDEI_LOG("> SIGNAL(e:%d t:%llx)\n", ev_num, x2);
+		ret = sdei_signal(ev_num, x2);
 		SDEI_LOG("< SIGNAL:%lld\n", ret);
-		SMC_RET1(handle, ret);
+		SMC_RET1(ctx, ret);
 
 	default:
 		/* Do nothing in default case */
@@ -1060,7 +1070,7 @@ uint64_t sdei_smc_handler(uint32_t smc_fid,
 	}
 
 	WARN("Unimplemented SDEI Call: 0x%x\n", smc_fid);
-	SMC_RET1(handle, SMC_UNK);
+	SMC_RET1(ctx, SMC_UNK);
 }
 
 /* Subscribe to PSCI CPU on to initialize per-CPU SDEI configuration */
diff --git a/services/std_svc/sdei/sdei_private.h b/services/std_svc/sdei/sdei_private.h
index 874fc22db..d99aceacb 100644
--- a/services/std_svc/sdei/sdei_private.h
+++ b/services/std_svc/sdei/sdei_private.h
@@ -4,8 +4,8 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
-#ifndef __SDEI_PRIVATE_H__
-#define __SDEI_PRIVATE_H__
+#ifndef SDEI_PRIVATE_H
+#define SDEI_PRIVATE_H
 
 #include <arch_helpers.h>
 #include <context_mgmt.h>
@@ -36,12 +36,12 @@
 #define SDEI_LOG(...)	VERBOSE("SDEI: " __VA_ARGS__)
 
 /* SDEI handler unregistered state. This is the default state. */
-#define SDEI_STATE_UNREGISTERED		0
+#define SDEI_STATE_UNREGISTERED		0U
 
 /* SDE event status values in bit position */
-#define SDEI_STATF_REGISTERED		0
-#define SDEI_STATF_ENABLED		1
-#define SDEI_STATF_RUNNING		2
+#define SDEI_STATF_REGISTERED		0U
+#define SDEI_STATF_ENABLED		1U
+#define SDEI_STATF_RUNNING		2U
 
 /* SDEI SMC error codes */
 #define	SDEI_EINVAL	(-2)
@@ -62,18 +62,18 @@
 #define SDEI_INFO_EV_ROUTING_MODE	3
 #define SDEI_INFO_EV_ROUTING_AFF	4
 
-#define SDEI_PRIVATE_MAPPING()	(&sdei_global_mappings[_SDEI_MAP_IDX_PRIV])
-#define SDEI_SHARED_MAPPING()	(&sdei_global_mappings[_SDEI_MAP_IDX_SHRD])
+#define SDEI_PRIVATE_MAPPING()	(&sdei_global_mappings[SDEI_MAP_IDX_PRIV_])
+#define SDEI_SHARED_MAPPING()	(&sdei_global_mappings[SDEI_MAP_IDX_SHRD_])
 
 #define for_each_mapping_type(_i, _mapping) \
-	for (_i = 0, _mapping = &sdei_global_mappings[i]; \
-			_i < _SDEI_MAP_IDX_MAX; \
-			_i++, _mapping = &sdei_global_mappings[i])
+	for ((_i) = 0, (_mapping) = &sdei_global_mappings[(_i)]; \
+			(_i) < SDEI_MAP_IDX_MAX_; \
+			(_i)++, (_mapping) = &sdei_global_mappings[(_i)])
 
 #define iterate_mapping(_mapping, _i, _map) \
-	for (_map = (_mapping)->map, _i = 0; \
-			_i < (_mapping)->num_maps; \
-			_i++, _map++)
+	for ((_map) = (_mapping)->map, (_i) = 0; \
+			(_i) < (_mapping)->num_maps; \
+			(_i)++, (_map)++)
 
 #define for_each_private_map(_i, _map) \
 	iterate_mapping(SDEI_PRIVATE_MAPPING(), _i, _map)
@@ -82,45 +82,45 @@
 	iterate_mapping(SDEI_SHARED_MAPPING(), _i, _map)
 
 /* SDEI_FEATURES */
-#define SDEI_FEATURE_BIND_SLOTS		0
-#define BIND_SLOTS_MASK			0xffff
-#define FEATURES_SHARED_SLOTS_SHIFT	16
-#define FEATURES_PRIVATE_SLOTS_SHIFT	0
+#define SDEI_FEATURE_BIND_SLOTS		0U
+#define BIND_SLOTS_MASK			0xffffU
+#define FEATURES_SHARED_SLOTS_SHIFT	16U
+#define FEATURES_PRIVATE_SLOTS_SHIFT	0U
 #define FEATURE_BIND_SLOTS(_priv, _shrd) \
-	((((_priv) & BIND_SLOTS_MASK) << FEATURES_PRIVATE_SLOTS_SHIFT) | \
-	 (((_shrd) & BIND_SLOTS_MASK) << FEATURES_SHARED_SLOTS_SHIFT))
+	(((((uint64_t) (_priv)) & BIND_SLOTS_MASK) << FEATURES_PRIVATE_SLOTS_SHIFT) | \
+	 ((((uint64_t) (_shrd)) & BIND_SLOTS_MASK) << FEATURES_SHARED_SLOTS_SHIFT))
 
 #define GET_EV_STATE(_e, _s)	get_ev_state_bit(_e, SDEI_STATF_##_s)
 #define SET_EV_STATE(_e, _s)	clr_ev_state_bit(_e->state, SDEI_STATF_##_s)
 
-static inline int is_event_private(sdei_ev_map_t *map)
+static inline bool is_event_private(sdei_ev_map_t *map)
 {
-	return ((map->map_flags & BIT(_SDEI_MAPF_PRIVATE_SHIFT)) != 0);
+	return ((map->map_flags & BIT_32(SDEI_MAPF_PRIVATE_SHIFT_)) != 0U);
 }
 
-static inline int is_event_shared(sdei_ev_map_t *map)
+static inline bool is_event_shared(sdei_ev_map_t *map)
 {
 	return !is_event_private(map);
 }
 
-static inline int is_event_critical(sdei_ev_map_t *map)
+static inline bool is_event_critical(sdei_ev_map_t *map)
 {
-	return ((map->map_flags & BIT(_SDEI_MAPF_CRITICAL_SHIFT)) != 0);
+	return ((map->map_flags & BIT_32(SDEI_MAPF_CRITICAL_SHIFT_)) != 0U);
 }
 
-static inline int is_event_normal(sdei_ev_map_t *map)
+static inline bool is_event_normal(sdei_ev_map_t *map)
 {
 	return !is_event_critical(map);
 }
 
-static inline int is_event_signalable(sdei_ev_map_t *map)
+static inline bool is_event_signalable(sdei_ev_map_t *map)
 {
-	return ((map->map_flags & BIT(_SDEI_MAPF_SIGNALABLE_SHIFT)) != 0);
+	return ((map->map_flags & BIT_32(SDEI_MAPF_SIGNALABLE_SHIFT_)) != 0U);
 }
 
-static inline int is_map_dynamic(sdei_ev_map_t *map)
+static inline bool is_map_dynamic(sdei_ev_map_t *map)
 {
-	return ((map->map_flags & BIT(_SDEI_MAPF_DYNAMIC_SHIFT)) != 0);
+	return ((map->map_flags & BIT_32(SDEI_MAPF_DYNAMIC_SHIFT_)) != 0U);
 }
 
 /*
@@ -129,29 +129,29 @@ static inline int is_map_dynamic(sdei_ev_map_t *map)
  * called on them. This can be used on both static or dynamic events to check
  * for an associated interrupt.
  */
-static inline int is_map_bound(sdei_ev_map_t *map)
+static inline bool is_map_bound(sdei_ev_map_t *map)
 {
-	return ((map->map_flags & BIT(_SDEI_MAPF_BOUND_SHIFT)) != 0);
+	return ((map->map_flags & BIT_32(SDEI_MAPF_BOUND_SHIFT_)) != 0U);
 }
 
 static inline void set_map_bound(sdei_ev_map_t *map)
 {
-	map->map_flags |= BIT(_SDEI_MAPF_BOUND_SHIFT);
+	map->map_flags |= BIT_32(SDEI_MAPF_BOUND_SHIFT_);
 }
 
-static inline int is_map_explicit(sdei_ev_map_t *map)
+static inline bool is_map_explicit(sdei_ev_map_t *map)
 {
-	return ((map->map_flags & BIT(_SDEI_MAPF_EXPLICIT_SHIFT)) != 0);
+	return ((map->map_flags & BIT_32(SDEI_MAPF_EXPLICIT_SHIFT_)) != 0U);
 }
 
 static inline void clr_map_bound(sdei_ev_map_t *map)
 {
-	map->map_flags &= ~(BIT(_SDEI_MAPF_BOUND_SHIFT));
+	map->map_flags &= ~BIT_32(SDEI_MAPF_BOUND_SHIFT_);
 }
 
-static inline int is_secure_sgi(unsigned int intr)
+static inline bool is_secure_sgi(unsigned int intr)
 {
-	return (plat_ic_is_sgi(intr) &&
+	return ((plat_ic_is_sgi(intr) != 0) &&
 			(plat_ic_get_interrupt_type(intr) == INTR_TYPE_EL3));
 }
 
@@ -164,24 +164,24 @@ static inline unsigned int sdei_client_el(void)
 	cpu_context_t *ns_ctx = cm_get_context(NON_SECURE);
 	el3_state_t *el3_ctx = get_el3state_ctx(ns_ctx);
 
-	return read_ctx_reg(el3_ctx, CTX_SCR_EL3) & SCR_HCE_BIT ? MODE_EL2 :
-		MODE_EL1;
+	return ((read_ctx_reg(el3_ctx, CTX_SCR_EL3) & SCR_HCE_BIT) != 0U) ?
+		MODE_EL2 : MODE_EL1;
 }
 
 static inline unsigned int sdei_event_priority(sdei_ev_map_t *map)
 {
-	return is_event_critical(map) ? PLAT_SDEI_CRITICAL_PRI :
-		PLAT_SDEI_NORMAL_PRI;
+	return (unsigned int) (is_event_critical(map) ? PLAT_SDEI_CRITICAL_PRI :
+			PLAT_SDEI_NORMAL_PRI);
 }
 
-static inline int get_ev_state_bit(sdei_entry_t *se, unsigned int bit_no)
+static inline bool get_ev_state_bit(sdei_entry_t *se, unsigned int bit_no)
 {
-	return ((se->state & BIT(bit_no)) != 0);
+	return ((se->state & BIT_32(bit_no)) != 0U);
 }
 
 static inline void clr_ev_state_bit(sdei_entry_t *se, unsigned int bit_no)
 {
-	se->state &= ~BIT(bit_no);
+	se->state &= ~BIT_32(bit_no);
 }
 
 /* SDEI actions for state transition */
@@ -228,19 +228,19 @@ extern sdei_entry_t sdei_shared_event_table[];
 
 void init_sdei_state(void);
 
-sdei_ev_map_t *find_event_map_by_intr(int intr_num, int shared);
+sdei_ev_map_t *find_event_map_by_intr(unsigned int intr_num, bool shared);
 sdei_ev_map_t *find_event_map(int ev_num);
 sdei_entry_t *get_event_entry(sdei_ev_map_t *map);
 
-int sdei_event_context(void *handle, unsigned int param);
-int sdei_event_complete(int resume, uint64_t arg);
+int64_t sdei_event_context(void *handle, unsigned int param);
+int sdei_event_complete(bool resume, uint64_t pc);
 
 void sdei_pe_unmask(void);
-unsigned int sdei_pe_mask(void);
+int64_t sdei_pe_mask(void);
 
-int sdei_intr_handler(uint32_t intr, uint32_t flags, void *handle,
+int sdei_intr_handler(uint32_t intr_raw, uint32_t flags, void *handle,
 		void *cookie);
 bool can_sdei_state_trans(sdei_entry_t *se, sdei_action_t act);
 void begin_sdei_synchronous_dispatch(struct jmpbuf *buffer);
 
-#endif /* __SDEI_PRIVATE_H__ */
+#endif /* SDEI_PRIVATE_H */
diff --git a/services/std_svc/sdei/sdei_state.c b/services/std_svc/sdei/sdei_state.c
index c1f099fa8..66657862d 100644
--- a/services/std_svc/sdei/sdei_state.c
+++ b/services/std_svc/sdei/sdei_state.c
@@ -10,13 +10,13 @@
 #include "sdei_private.h"
 
 /* Aliases for SDEI handler states: 'R'unning, 'E'nabled, and re'G'istered */
-#define r_		0
+#define r_		0U
 #define R_		(1u << SDEI_STATF_RUNNING)
 
-#define e_		0
+#define e_		0U
 #define E_		(1u << SDEI_STATF_ENABLED)
 
-#define g_		0
+#define g_		0U
 #define G_		(1u << SDEI_STATF_REGISTERED)
 
 /* All possible composite handler states */
@@ -29,7 +29,7 @@
 #define REg_		(R_ | E_ | g_)
 #define REG_		(R_ | E_ | G_)
 
-#define MAX_STATES	(REG_ + 1)
+#define MAX_STATES	(REG_ + 1u)
 
 /* Invalid state */
 #define	SDEI_STATE_INVALID	((sdei_state_t) (-1))
-- 
2.21.1 (Apple Git-122.3)

